# ============================================================================
# CI/CD Pipeline for FREDDY - Personal & Authentication Services Server
# ============================================================================
# Personal home server running photos, cloud storage, home automation
# Repository: nuniesmith/freddy
#
# Services: nginx, photoprism, nextcloud, homeassistant, audiobookshelf
#
# Features:
#   - Cloudflare DNS management (update A records to Tailscale IPs)
#   - SSL certificate generation via Certbot with Cloudflare DNS challenge
#   - Deployment via Tailscale + SSH
# ============================================================================

name: üè† Freddy Deploy

on:
    push:
        branches:
            - main
        paths-ignore:
            - "**.md"
            - "docs/**"
            - ".gitignore"
    pull_request:
        branches: [main]
    workflow_dispatch:
        inputs:
            skip_deploy:
                description: "Skip deployment (test workflow only)"
                required: false
                type: boolean
                default: false
            update_dns:
                description: "Update Cloudflare DNS records"
                required: false
                type: boolean
                default: true
            force_ssl_regen:
                description: "Force SSL certificate regeneration (fixes corrupted certs)"
                required: false
                type: boolean
                default: false
            use_staging_certs:
                description: "Use Let's Encrypt staging server (for testing, avoids rate limits)"
                required: false
                type: boolean
                default: false
            reset_nextcloud_db:
                description: "Reset Nextcloud PostgreSQL database (fixes password authentication issues)"
                required: false
                type: boolean
                default: false
    schedule:
        # Run SSL renewal check weekly on Sundays at 3am UTC
        - cron: "0 3 * * 0"

permissions:
    contents: read

env:
    SERVER_NAME: freddy
    PROJECT_PATH: freddy
    DOMAIN: 7gram.xyz

    # Freddy DNS records (services hosted on freddy)
    FREDDY_DNS_RECORDS: >-
        7gram.xyz
        *.7gram.xyz
        nc.7gram.xyz
        photo.7gram.xyz
        home.7gram.xyz
        abs.7gram.xyz

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

defaults:
    run:
        shell: bash

jobs:
    # ==========================================================================
    # CLOUDFLARE DNS UPDATE
    # ==========================================================================
    dns-update:
        name: üåê Update Cloudflare DNS
        runs-on: ubuntu-latest
        timeout-minutes: 10
        if: |
            github.event_name == 'workflow_dispatch' && inputs.update_dns ||
            github.event_name == 'push' ||
            github.event_name == 'schedule'

        outputs:
            dns-updated: ${{ steps.dns-freddy.outputs.updated }}

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üåê Update Freddy DNS Records
              id: dns-freddy
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: ${{ env.DOMAIN }}
                  record-content: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  record-type: A
                  ttl: "1"
                  proxied: "false"
                  additional-records: |
                      [
                        {"name": "nc.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "photo.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "home.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "abs.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "freddy.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"}
                      ]

            - name: üåê Update Sullivan DNS Records (proxied via Freddy nginx)
              id: dns-sullivan
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: sullivan.7gram.xyz
                  record-content: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  record-type: A
                  ttl: "1"
                  proxied: "false"
                  additional-records: |
                      [
                        {"name": "jellyfin.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "emby.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "plex.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "sonarr.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "radarr.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "lidarr.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "jackett.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "qbt.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "calibre.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "yt.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "filebot.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "grocy.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "mealie.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "wiki.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "duplicati.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"}
                      ]

            - name: üìã DNS Update Summary
              run: |
                  echo "## üåê DNS Update Summary" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Target IP (Freddy Tailscale):** \`${{ secrets.FREDDY_TAILSCALE_IP }}\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "All DNS records for 7gram.xyz have been updated to point to the Freddy server." >> $GITHUB_STEP_SUMMARY
                  echo "Freddy's nginx will reverse proxy Sullivan services over Tailscale." >> $GITHUB_STEP_SUMMARY

    # ==========================================================================
    # DEPLOYMENT (includes SSL generation)
    # ==========================================================================
    deploy:
        name: üöÄ Deploy to Freddy
        runs-on: ubuntu-latest
        timeout-minutes: 30
        needs: dns-update
        outputs:
            cert_exists: ${{ steps.check-certs.outputs.cert_exists }}
            needs_renewal: ${{ steps.check-certs.outputs.needs_renewal }}
            expiry_date: ${{ steps.check-certs.outputs.expiry_date }}
            days_until_expiry: ${{ steps.check-certs.outputs.days_until_expiry }}
        if: |
            always() &&
            (needs.dns-update.result == 'success' || needs.dns-update.result == 'skipped') &&
            (
              github.event_name == 'push' ||
              github.event_name == 'schedule' ||
              github.event_name == 'workflow_dispatch' && inputs.skip_deploy != true
            )

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            # ======================================================================
            # TAILSCALE CONNECTION
            # ======================================================================
            - name: üîå Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  target-ssh-port: ${{ secrets.SSH_PORT || '22' }}

            # ======================================================================
            # SSL CERTIFICATE GENERATION
            # ======================================================================
            - name: üßπ Clean corrupted SSL certificates
              if: inputs.force_ssl_regen == true
              run: |
                  echo "üßπ Forcing comprehensive SSL certificate cleanup..."
                  echo "This will remove ALL existing certificates from ssl-certs Docker volume"

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} << 'ENDSSH'

                  set -e
                  echo "================================================"
                  echo "  SSL CERTIFICATE CLEANUP (Docker Volume)"
                  echo "================================================"

                  # Stop nginx to release any file locks
                  echo "‚Üí Stopping nginx container..."
                  docker stop nginx 2>/dev/null || true
                  docker rm nginx 2>/dev/null || true

                  # Remove and recreate ssl-certs volume
                  echo "‚Üí Removing ssl-certs Docker volume..."
                  docker volume rm ssl-certs 2>/dev/null || true
                  docker volume rm freddy_ssl-certs 2>/dev/null || true

                  echo "‚Üí Creating fresh ssl-certs volume..."
                  docker volume create ssl-certs

                  echo ""
                  echo "‚úÖ Docker volume cleanup finished"
                  echo "   Ready for fresh SSL certificate generation"
                  echo "================================================"
                  ENDSSH

                  # Cleanup SSH key
                  rm -f ~/.ssh/id_rsa
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: üîç Check existing SSL certificates
              id: check-certs
              continue-on-error: true
              run: |
                  echo "üîç Checking existing SSL certificates..."

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  # Create temporary script for remote execution
                  cat > /tmp/check_certs.sh << 'SCRIPTEOF'
                  #!/bin/bash
                  # Check if ssl-certs volume exists and has certificates
                  if docker volume inspect ssl-certs >/dev/null 2>&1; then
                    if docker run --rm -v ssl-certs:/certs:ro busybox:latest test -f /certs/live/7gram.xyz/fullchain.pem 2>/dev/null; then
                      # Get certificate expiry date
                      EXPIRY_DATE=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -in /certs/live/7gram.xyz/fullchain.pem -noout -enddate 2>/dev/null | cut -d= -f2 || echo "")

                      if [ -n "$EXPIRY_DATE" ]; then
                        EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s 2>/dev/null || echo "0")
                        CURRENT_EPOCH=$(date +%s)
                        DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_EPOCH - $CURRENT_EPOCH) / 86400 ))

                        # Get issuer to determine cert type
                        ISSUER=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -in /certs/live/7gram.xyz/fullchain.pem -noout -issuer 2>/dev/null || echo "")

                        echo "CERT_EXISTS=true"
                        echo "EXPIRY_DATE=$EXPIRY_DATE"
                        echo "DAYS_UNTIL_EXPIRY=$DAYS_UNTIL_EXPIRY"
                        echo "ISSUER=$ISSUER"

                        # Renew if less than 30 days remaining
                        if [ "$DAYS_UNTIL_EXPIRY" -lt 30 ]; then
                          echo "NEEDS_RENEWAL=true"
                        else
                          echo "NEEDS_RENEWAL=false"
                        fi
                        exit 0
                      fi
                    fi
                  fi

                  echo "CERT_EXISTS=false"
                  echo "NEEDS_RENEWAL=true"
                  exit 0
                  SCRIPTEOF

                  # Run script on remote server
                  CERT_CHECK=$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} \
                    'bash -s' < /tmp/check_certs.sh 2>/dev/null || echo "CERT_EXISTS=false
                  NEEDS_RENEWAL=true")

                  # Clean up temp file
                  rm -f /tmp/check_certs.sh

                  # Parse the output (use defaults if parsing fails)
                  CERT_EXISTS=$(echo "$CERT_CHECK" | grep "CERT_EXISTS=" | cut -d= -f2 | head -1 || echo "false")
                  EXPIRY_DATE=$(echo "$CERT_CHECK" | grep "EXPIRY_DATE=" | cut -d= -f2- | head -1 || echo "")
                  DAYS_UNTIL_EXPIRY=$(echo "$CERT_CHECK" | grep "DAYS_UNTIL_EXPIRY=" | cut -d= -f2 | head -1 || echo "0")
                  ISSUER=$(echo "$CERT_CHECK" | grep "ISSUER=" | cut -d= -f2- | head -1 || echo "")
                  NEEDS_RENEWAL=$(echo "$CERT_CHECK" | grep "NEEDS_RENEWAL=" | cut -d= -f2 | head -1 || echo "true")

                  # Clean up SSH key
                  rm -f ~/.ssh/id_rsa

                  # Set outputs (always set, even if empty)
                  echo "cert_exists=${CERT_EXISTS:-false}" >> $GITHUB_OUTPUT
                  echo "needs_renewal=${NEEDS_RENEWAL:-true}" >> $GITHUB_OUTPUT
                  echo "expiry_date=${EXPIRY_DATE:-unknown}" >> $GITHUB_OUTPUT
                  echo "days_until_expiry=${DAYS_UNTIL_EXPIRY:-0}" >> $GITHUB_OUTPUT

                  # Display results
                  if [ "$CERT_EXISTS" = "true" ]; then
                    echo "‚úÖ Existing certificates found"
                    echo "üìÖ Expires: $EXPIRY_DATE"
                    echo "‚è∞ Days until expiry: $DAYS_UNTIL_EXPIRY"
                    echo "üîê Issuer: $ISSUER"

                    if [ "$NEEDS_RENEWAL" = "true" ]; then
                      echo "‚ö†Ô∏è  Certificates need renewal (< 30 days remaining)"
                    else
                      echo "‚úÖ Certificates are still valid (> 30 days remaining)"
                    fi
                  else
                    echo "‚ö†Ô∏è  No existing certificates found - will generate new ones"
                  fi
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: üîê Generate SSL Certificates (Let's Encrypt + Cloudflare DNS)
              id: certbot
              if: steps.check-certs.outputs.needs_renewal == 'true' || inputs.force_ssl_regen == true
              uses: nuniesmith/actions/.github/actions/ssl-certbot-cloudflare@main
              with:
                  domain: ${{ env.DOMAIN }}
                  # Note: Don't include specific subdomains that are covered by wildcards
                  # *.7gram.xyz covers nc, photo, home, abs, sullivan, etc.
                  # *.sullivan.7gram.xyz covers any sullivan subdomains
                  additional-domains: "*.7gram.xyz,*.sullivan.7gram.xyz"
                  cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  email: ${{ secrets.SSL_EMAIL }}
                  propagation-seconds: 60
                  staging: ${{ inputs.use_staging_certs || false }}
                  fallback-to-self-signed: true
                  deploy-to-server: false

            - name: üì¶ Deploy certificates to Docker volume
              id: deploy-certs
              if: steps.certbot.outcome == 'success'
              run: |
                  echo "üì¶ Deploying SSL certificates to Freddy server..."

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  # Transfer certificate tarball to server
                  echo "üì§ Transferring certificates..."
                  scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -P ${{ secrets.SSH_PORT || '22' }} \
                    /tmp/ssl-certs.tar.gz \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }}:/tmp/

                  # Create deployment script
                  cat > /tmp/deploy_certs.sh << 'SCRIPTEOF'
                  #!/bin/bash
                  # Ensure ssl-certs volume exists
                  docker volume inspect ssl-certs >/dev/null 2>&1 || docker volume create ssl-certs

                  # Extract certificates into the volume and clean up in one step
                  docker run --rm -v ssl-certs:/certs -v /tmp:/tmp busybox sh -c "cd /certs && tar -xzf /tmp/ssl-certs.tar.gz && ls -la /certs/live/7gram.xyz/ && rm -f /tmp/ssl-certs.tar.gz && echo 'Certificates deployed successfully'"

                  echo "‚úÖ Certificates deployed to ssl-certs Docker volume"
                  SCRIPTEOF

                  # Deploy to Docker volume on server
                  echo "üîê Extracting certificates to Docker volume..."
                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} \
                    'bash -s' < /tmp/deploy_certs.sh

                  # Clean up SSH key and local files
                  rm -f ~/.ssh/id_rsa
                  rm -f /tmp/ssl-certs.tar.gz
                  rm -f /tmp/deploy_certs.sh

                  echo "‚úÖ SSL certificate deployment complete"
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: ‚úÖ Verify SSL certificates in Docker volume
              if: steps.certbot.outcome == 'success' || steps.check-certs.outputs.cert_exists == 'true'
              run: |
                  echo "üîç Verifying SSL certificates in Docker volume..."
                  echo "Note: Let's Encrypt uses ECDSA P-256 keys (241 bytes) - this is normal and secure"

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} << 'ENDSSH'

                  echo "================================================"
                  echo "  SSL CERTIFICATE VERIFICATION (Docker Volume)"
                  echo "================================================"

                  # Check if ssl-certs volume exists
                  if docker volume inspect ssl-certs >/dev/null 2>&1; then
                    echo "‚úì ssl-certs volume exists"

                    # Check if certificates exist in volume
                    if docker run --rm -v ssl-certs:/certs:ro busybox:latest test -f /certs/live/7gram.xyz/fullchain.pem 2>/dev/null; then
                      echo "‚úì Let's Encrypt certificates found in volume"

                      # List certificate files
                      echo ""
                      echo "Certificate files in ssl-certs volume:"
                      docker run --rm -v ssl-certs:/certs:ro busybox:latest ls -lah /certs/live/7gram.xyz/

                      # Verify certificate details
                      echo ""
                      echo "Certificate details:"
                      docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -in /certs/live/7gram.xyz/fullchain.pem -noout -issuer -dates -subject 2>/dev/null || true

                      # Verify certificate and private key match (supports both RSA and ECDSA)
                      echo ""
                      echo "Verifying certificate/key pair..."
                      CERT_PUBKEY=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -noout -pubkey -in /certs/live/7gram.xyz/fullchain.pem 2>/dev/null | sha256sum | cut -d' ' -f1)
                      KEY_PUBKEY=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl pkey -pubout -in /certs/live/7gram.xyz/privkey.pem 2>/dev/null | sha256sum | cut -d' ' -f1)

                      if [ -n "$CERT_PUBKEY" ] && [ "$CERT_PUBKEY" = "$KEY_PUBKEY" ]; then
                        echo "‚úì Certificate and private key match (public key verified)"

                        # Detect key type
                        KEY_TYPE=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl pkey -text -noout -in /certs/live/7gram.xyz/privkey.pem 2>/dev/null | head -1)
                        echo "  Key type: $KEY_TYPE"
                      else
                        echo "‚ö†Ô∏è Could not verify certificate/key match"
                        echo "  Certificate files exist and appear valid"
                      fi
                    else
                      echo "‚ö†Ô∏è No Let's Encrypt certificates found in volume"
                      echo "   Volume contents:"
                      docker run --rm -v ssl-certs:/certs:ro busybox:latest ls -la /certs/ 2>/dev/null || echo "   Volume is empty"
                    fi
                  else
                    echo "‚úó ssl-certs volume does not exist"
                  fi

                  echo "================================================"
                  ENDSSH

                  # Cleanup SSH key
                  rm -f ~/.ssh/id_rsa
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            # ======================================================================
            # DEPLOY VIA SSH
            # ======================================================================
            - name: üöÄ Deploy via SSH
              id: deploy
              if: steps.tailscale.outputs.connected == 'true'
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  port: ${{ secrets.SSH_PORT || '22' }}
                  username: ${{ secrets.SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.SSH_KEY }}
                  project-path: ${{ env.PROJECT_PATH }}
                  git-pull: false
                  git-branch: ${{ github.ref_name }}
                  docker-prune: false
                  pre-deploy-command: |
                      echo "üè† Deploying to Freddy server..."

                      # Create project directory if it doesn't exist
                      echo "üìÅ Ensuring project directory exists..."
                      mkdir -p $HOME/${{ env.PROJECT_PATH }}
                      cd $HOME/${{ env.PROJECT_PATH }}

                      # Handle git repository setup early (needed for run.sh)
                      if [ -d .git ] && git status >/dev/null 2>&1; then
                        echo "üì• Updating existing repository..."
                        git fetch origin
                        git checkout ${{ github.ref_name }}
                        git pull origin ${{ github.ref_name }} || {
                          echo "‚ö†Ô∏è Git pull failed, doing hard reset..."
                          git reset --hard origin/${{ github.ref_name }}
                        }
                      else
                        echo "üì• Cloning repository (first deployment)..."
                        cd ~
                        rm -rf $HOME/${{ env.PROJECT_PATH }}
                        git clone https://github.com/${{ github.repository }}.git $HOME/${{ env.PROJECT_PATH }}
                        cd $HOME/${{ env.PROJECT_PATH }}
                        git checkout ${{ github.ref_name }}
                      fi

                      # Ensure run.sh is executable
                      chmod +x ./run.sh 2>/dev/null || true

                      echo "üîê Setting up .env file..."

                      # Try run.sh first (primary method)
                      ENV_CREATED=false
                      if [ -f ./run.sh ]; then
                        echo "   ‚ñ∂ Running: bash ./run.sh setup-env"
                        bash ./run.sh setup-env 2>&1 || true
                        if [ -f .env ] && [ -s .env ]; then
                          echo "   ‚úÖ .env exists after run.sh ($(wc -l < .env) lines)"
                          ENV_CREATED=true
                        fi
                      fi

                      # Fallback: create .env directly
                      if [ "$ENV_CREATED" != "true" ]; then
                        echo "   üîÑ Fallback: Creating .env directly..."
                        GEN_PASS() { openssl rand -base64 24 2>/dev/null | tr -d '/+=' | head -c 16 || cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 16 | head -n 1; }
                        GEN_SECRET() { openssl rand -hex 16 2>/dev/null || cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1; }

                        cat > .env << 'ENVEOF'
                      # Freddy Home Server - Auto-generated by CI/CD fallback
                      ENVEOF
                        # Generate with variable expansion
                        cat >> .env << ENVEOF
                      TZ=${{ secrets.TZ || 'America/Toronto' }}
                      PUID=${{ secrets.PUID || '1000' }}
                      PGID=${{ secrets.PGID || '1000' }}
                      PHOTOPRISM_ADMIN_PASSWORD=$(GEN_PASS)
                      PHOTOPRISM_DB_NAME=photoprism
                      PHOTOPRISM_DB_USER=photoprism
                      PHOTOPRISM_DB_PASSWORD=$(GEN_PASS)
                      NEXTCLOUD_DB_NAME=nextcloud
                      NEXTCLOUD_DB_USER=nextcloud
                      NEXTCLOUD_DB_PASSWORD=$(GEN_PASS)
                      NEXTCLOUD_ADMIN_USER=admin
                      NEXTCLOUD_ADMIN_PASSWORD=$(GEN_PASS)
                      SULLIVAN_TAILSCALE_IP=${{ secrets.SULLIVAN_TAILSCALE_IP || '100.87.125.19' }}
                      MEDIA_PATH_AUDIOBOOKS=${{ secrets.MEDIA_PATH_AUDIOBOOKS || '/media/audiobooks' }}
                      ENVEOF
                        sed -i 's/^                      //' .env
                        echo "   ‚úÖ Fallback .env created ($(wc -l < .env) lines)"
                      fi

                      # Verify critical keys
                      MISSING_KEYS=0
                      for key in TZ PHOTOPRISM_ADMIN_PASSWORD NEXTCLOUD_ADMIN_PASSWORD; do
                        grep -q "^${key}=" .env 2>/dev/null || MISSING_KEYS=$((MISSING_KEYS + 1))
                      done
                      if [ "$MISSING_KEYS" -gt 2 ]; then
                        echo "   ‚ùå Too many critical keys missing ($MISSING_KEYS)"
                        exit 1
                      fi
                      echo "   ‚úÖ .env verification passed ($(grep -c '^[A-Z_]' .env 2>/dev/null || echo '?') keys)"

                      # Inject secrets from GitHub Actions (if provided)
                      echo "üîê Injecting secrets from GitHub Actions..."
                      if [ -n "${{ secrets.PHOTOPRISM_ADMIN_PASSWORD }}" ]; then
                        sed -i "s/^PHOTOPRISM_ADMIN_PASSWORD=.*/PHOTOPRISM_ADMIN_PASSWORD=${{ secrets.PHOTOPRISM_ADMIN_PASSWORD }}/" .env
                      fi
                      if [ -n "${{ secrets.PHOTOPRISM_DB_PASSWORD }}" ]; then
                        sed -i "s/^PHOTOPRISM_DB_PASSWORD=.*/PHOTOPRISM_DB_PASSWORD=${{ secrets.PHOTOPRISM_DB_PASSWORD }}/" .env
                      fi
                      if [ -n "${{ secrets.NEXTCLOUD_DB_PASSWORD }}" ]; then
                        sed -i "s/^NEXTCLOUD_DB_PASSWORD=.*/NEXTCLOUD_DB_PASSWORD=${{ secrets.NEXTCLOUD_DB_PASSWORD }}/" .env
                      fi
                      if [ -n "${{ secrets.NEXTCLOUD_ADMIN_USER }}" ]; then
                        sed -i "s/^NEXTCLOUD_ADMIN_USER=.*/NEXTCLOUD_ADMIN_USER=${{ secrets.NEXTCLOUD_ADMIN_USER }}/" .env
                      fi
                      if [ -n "${{ secrets.NEXTCLOUD_ADMIN_PASSWORD }}" ]; then
                        sed -i "s/^NEXTCLOUD_ADMIN_PASSWORD=.*/NEXTCLOUD_ADMIN_PASSWORD=${{ secrets.NEXTCLOUD_ADMIN_PASSWORD }}/" .env
                      fi
                      echo "   ‚úÖ Secrets injected"

                      chmod 600 .env
                      echo ""

                      # Ensure all bind-mount directories for Docker volumes exist
                      # Docker will NOT auto-create these for local driver bind mounts
                      # Uses a busybox container to create dirs as root (no sudo needed)
                      echo "üìÅ Ensuring volume mount directories exist..."
                      docker run --rm -v /mnt/1tb:/mnt busybox sh -c "\
                        mkdir -p \
                          /mnt/photos \
                          /mnt/photoprism/storage \
                          /mnt/photoprism/postgres \
                          /mnt/nextcloud/html \
                          /mnt/nextcloud/data \
                          /mnt/nextcloud/postgres \
                          /mnt/homeassistant \
                        && chown -R 33:33 /mnt/nextcloud/html /mnt/nextcloud/data \
                        && echo '  ‚úÖ Volume directories ready'"

                      # Reset Nextcloud PostgreSQL database if requested
                      # This fixes password authentication issues when credentials don't match existing database
                      if [ "${{ inputs.reset_nextcloud_db }}" = "true" ]; then
                        echo "üîÑ Resetting Nextcloud PostgreSQL database..."
                        echo "   ‚ö†Ô∏è  This will DELETE all Nextcloud database data!"
                        echo "   (Fixes password mismatch issues)"
                        docker stop nextcloud nextcloud-cron nextcloud-postgres 2>/dev/null || true
                        docker rm nextcloud nextcloud-cron nextcloud-postgres 2>/dev/null || true
                        docker run --rm -v /mnt/1tb:/mnt busybox sh -c "\
                          rm -rf /mnt/nextcloud/postgres/* \
                          && echo '  ‚úÖ Nextcloud PostgreSQL data reset (will reinitialize with current credentials)'"
                      fi

                      # Stop existing services to release file locks
                      echo "üõë Stopping existing services..."
                      if [ -d "$HOME/${{ env.PROJECT_PATH }}" ]; then
                        cd $HOME/${{ env.PROJECT_PATH }}
                        ./run.sh stop 2>/dev/null || docker compose down 2>/dev/null || true
                        cd ~
                      fi

                      # Note: SSL certificate cleanup is handled by the
                      # force_ssl_regen workflow input. We don't remove certificates
                      # here to preserve fresh certs from the SSL generation step.

                      # Verify SSL certificates are ready in Docker volume
                      echo "üîç Checking for SSL certificates in Docker volume..."

                      # Check if ssl-certs volume exists and has certificates
                      if docker volume inspect ssl-certs >/dev/null 2>&1; then
                        if docker run --rm -v ssl-certs:/certs:ro busybox:latest test -f /certs/live/${{ env.DOMAIN }}/fullchain.pem 2>/dev/null; then
                          echo "‚úÖ Let's Encrypt certificates found in ssl-certs volume"
                          docker run --rm -v ssl-certs:/certs:ro busybox:latest ls -lah /certs/live/${{ env.DOMAIN }}/

                          # Verify certificate details
                          echo "üîê Certificate details:"
                          docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -in /certs/live/${{ env.DOMAIN }}/fullchain.pem -noout -issuer -dates 2>/dev/null || true

                          # Verify certificate and key match
                          CERT_PK=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -noout -pubkey -in /certs/live/${{ env.DOMAIN }}/fullchain.pem 2>/dev/null | sha256sum | cut -d' ' -f1)
                          KEY_PK=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl pkey -pubout -in /certs/live/${{ env.DOMAIN }}/privkey.pem 2>/dev/null | sha256sum | cut -d' ' -f1)

                          if [ -n "$CERT_PK" ] && [ "$CERT_PK" = "$KEY_PK" ]; then
                            echo "‚úÖ Certificate and private key verified (match confirmed)"
                          else
                            echo "‚úÖ Certificates present (will be validated by nginx on startup)"
                          fi

                          echo "‚úÖ Nginx will use Let's Encrypt production certificates"
                        else
                          echo "‚ö†Ô∏è  No Let's Encrypt certificates found in volume"
                          echo "   Nginx will start using self-signed fallback certificates"
                        fi
                      else
                        echo "‚ö†Ô∏è  ssl-certs volume does not exist yet"
                        echo "   Volume will be created during deployment"
                        echo "   Nginx will start using self-signed fallback certificates"
                      fi
                      echo ""

                      # Load environment variables
                      if [ -f .env ]; then
                        set -a && source .env && set +a
                        echo "‚úì Environment loaded"
                      fi

                  deploy-command: |
                      # Action already cd's to PROJECT_PATH; use absolute path as safeguard
                      cd $HOME/${{ env.PROJECT_PATH }}

                      # Stop and remove existing containers + networks
                      # (run.sh stop only stops containers without removing them,
                      #  causing name conflicts on docker compose up)
                      echo "üê≥ Stopping existing services..."
                      docker compose down --remove-orphans 2>/dev/null || true

                      # Ensure ssl-certs external volume exists
                      echo "üîê Ensuring ssl-certs external volume exists..."
                      if ! docker volume inspect ssl-certs >/dev/null 2>&1; then
                        echo "  ‚Üí Creating ssl-certs volume..."
                        docker volume create ssl-certs
                      else
                        echo "  ‚úì ssl-certs volume already exists"
                      fi

                      # Build nginx image (uses cache ‚Äî only rebuilds if Dockerfile/config changed)
                      # SSL certs are mounted via the ssl-certs Docker volume, not baked in
                      echo "üî® Building nginx image..."
                      docker compose build nginx

                      # Pull latest images and start all services in one pass
                      echo "üöÄ Pulling images & starting all services..."
                      docker compose up -d --pull always --force-recreate --remove-orphans

                      echo "‚úÖ Deployment complete"

                  post-deploy-command: |
                      cd $HOME/${{ env.PROJECT_PATH }}

                      echo ""
                      echo "üìä Service Status:"
                      docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || docker ps --format "table {{.Names}}\t{{.Status}}"

                      echo ""
                      echo "‚úÖ Deployment complete!"

            # ======================================================================
            # HEALTH CHECKS
            # ======================================================================
            - name: üè• Run Health Checks
              id: health-checks
              if: always() && steps.deploy.outcome == 'success'
              uses: nuniesmith/actions/.github/actions/health-check@main
              with:
                  # Note: health-check action expects SPACE-separated container names
                  containers: nginx photoprism nextcloud homeassistant audiobookshelf
                  ssh-host: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  ssh-port: ${{ secrets.SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.SSH_KEY }}
                  initial-delay: 30
                  retry-count: 3
                  retry-delay: 10
                  fail-on-unhealthy: false

            # ======================================================================
            # DISCORD NOTIFICATION (Optional)
            # ======================================================================
            - name: üì£ Notify deployment
              if: always()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "üè† Freddy Deployment"
                  description: "Personal services server deployment"
                  status: ${{ steps.deploy.outcome == 'success' && 'success' || 'failure' }}
                  include-repo-info: true
                  fields: |
                      [
                        {"name": "Server", "value": "Freddy", "inline": true},
                        {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true},
                        {"name": "Health", "value": "${{ steps.health-checks.outputs.healthy == 'true' && '‚úÖ Healthy' || '‚ö†Ô∏è Check Required' }}", "inline": true}
                      ]

    # ==========================================================================
    # PIPELINE SUMMARY
    # ==========================================================================
    summary:
        name: üìä Summary
        runs-on: ubuntu-latest
        timeout-minutes: 10
        needs: [dns-update, deploy]
        if: always()

        steps:
            - name: üìä Generate summary
              run: |
                  echo "## üè† Freddy Deployment Summary" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
                  echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

                  # DNS Update status
                  if [ "${{ needs.dns-update.result }}" = "success" ]; then
                    echo "| üåê DNS Update | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY
                  elif [ "${{ needs.dns-update.result }}" = "skipped" ]; then
                    echo "| üåê DNS Update | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "| üåê DNS Update | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
                  fi

                  # Deploy status (includes SSL generation)
                  if [ "${{ needs.deploy.result }}" = "success" ]; then
                    echo "| üöÄ Deploy (SSL + Services) | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY
                  elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
                    echo "| üöÄ Deploy (SSL + Services) | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "| üöÄ Deploy (SSL + Services) | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
                  fi

                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "### üìã Details" >> $GITHUB_STEP_SUMMARY
                  echo "- **Server:** Freddy (Personal Services)" >> $GITHUB_STEP_SUMMARY
                  echo "- **Domain:** ${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
                  echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
                  echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
                  echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "### üîß Architecture" >> $GITHUB_STEP_SUMMARY
                  echo "- All DNS records point to Freddy's Tailscale IP" >> $GITHUB_STEP_SUMMARY
                  echo "- Freddy's nginx reverse proxies Sullivan services over Tailscale" >> $GITHUB_STEP_SUMMARY
                  echo "- SSL certificates cover both Freddy and Sullivan subdomains" >> $GITHUB_STEP_SUMMARY

            - name: üìã SSL Certificate Summary
              run: |
                  echo "## üîê SSL Certificate Status" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY

                  if [ "${{ needs.deploy.outputs.cert_exists }}" == "true" ]; then
                    echo "‚úÖ **Certificate Status:** Valid" >> $GITHUB_STEP_SUMMARY
                    echo "üìÖ **Expires:** ${{ needs.deploy.outputs.expiry_date }}" >> $GITHUB_STEP_SUMMARY
                    echo "‚è∞ **Days Remaining:** ${{ needs.deploy.outputs.days_until_expiry }}" >> $GITHUB_STEP_SUMMARY
                    echo "" >> $GITHUB_STEP_SUMMARY

                    if [ "${{ needs.deploy.outputs.needs_renewal }}" == "true" ]; then
                      echo "‚ö†Ô∏è Certificates were renewed during this deployment" >> $GITHUB_STEP_SUMMARY
                    else
                      echo "‚úÖ Certificates are valid - renewal skipped" >> $GITHUB_STEP_SUMMARY
                    fi
                  else
                    echo "‚ö†Ô∏è **Certificate Status:** New certificates generated" >> $GITHUB_STEP_SUMMARY
                  fi

            - name: ‚ùå Fail on deployment error
              if: needs.deploy.result == 'failure'
              run: |
                  echo "‚ùå Deployment failed"
                  exit 1
