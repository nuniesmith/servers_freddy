# ============================================================================
# CI/CD Pipeline for FREDDY - Personal & Authentication Services Server
# ============================================================================
# Personal home server running photos, cloud storage, home automation
# Repository: nuniesmith/freddy
#
# Services: nginx, photoprism, nextcloud, homeassistant, audiobookshelf
#
# Features:
#   - Cloudflare DNS management (update A records to Tailscale IPs)
#   - SSL certificate generation via Certbot with Cloudflare DNS challenge
#   - Deployment via Tailscale + SSH
# ============================================================================

name: üè† Freddy Deploy

on:
    push:
        branches:
            - main
        paths-ignore:
            - "**.md"
            - "docs/**"
            - ".gitignore"
    pull_request:
        branches: [main]
    workflow_dispatch:
        inputs:
            skip_deploy:
                description: "Skip deployment (test workflow only)"
                required: false
                type: boolean
                default: false
            update_dns:
                description: "Update Cloudflare DNS records"
                required: false
                type: boolean
                default: true
            force_ssl_regen:
                description: "Force SSL certificate regeneration (fixes corrupted certs)"
                required: false
                type: boolean
                default: false
    schedule:
        # Run SSL renewal check weekly on Sundays at 3am UTC
        - cron: "0 3 * * 0"

permissions:
    contents: read

env:
    SERVER_NAME: freddy
    PROJECT_PATH: ~/freddy
    DOMAIN: 7gram.xyz
    SSL_CERT_PATH: /opt/ssl/7gram.xyz

    # Freddy DNS records (services hosted on freddy)
    FREDDY_DNS_RECORDS: >-
        7gram.xyz
        *.7gram.xyz
        nc.7gram.xyz
        photo.7gram.xyz
        home.7gram.xyz
        audiobook.7gram.xyz

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

defaults:
    run:
        shell: bash

jobs:
    # ==========================================================================
    # CLOUDFLARE DNS UPDATE
    # ==========================================================================
    dns-update:
        name: üåê Update Cloudflare DNS
        runs-on: ubuntu-latest
        timeout-minutes: 10
        if: |
            github.event_name == 'workflow_dispatch' && inputs.update_dns ||
            github.event_name == 'push' ||
            github.event_name == 'schedule'

        outputs:
            dns-updated: ${{ steps.dns-freddy.outputs.updated }}

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üåê Update Freddy DNS Records
              id: dns-freddy
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: ${{ env.DOMAIN }}
                  record-content: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  record-type: A
                  ttl: "1"
                  proxied: "false"
                  additional-records: |
                      [
                        {"name": "nc.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "photo.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "home.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "abs.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "freddy.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"}
                      ]

            - name: üåê Update Sullivan DNS Records (proxied via Freddy nginx)
              id: dns-sullivan
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: sullivan.7gram.xyz
                  record-content: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  record-type: A
                  ttl: "1"
                  proxied: "false"
                  additional-records: |
                      [
                        {"name": "jellyfin.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "emby.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "plex.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "sonarr.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "radarr.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "lidarr.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "jackett.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "qbt.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "calibre.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "yt.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "filebot.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "grocy.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "mealie.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "wiki.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"},
                        {"name": "duplicati.7gram.xyz", "content": "${{ secrets.FREDDY_TAILSCALE_IP }}"}
                      ]

            - name: üìã DNS Update Summary
              run: |
                  echo "## üåê DNS Update Summary" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Target IP (Freddy Tailscale):** \`${{ secrets.FREDDY_TAILSCALE_IP }}\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "All DNS records for 7gram.xyz have been updated to point to the Freddy server." >> $GITHUB_STEP_SUMMARY
                  echo "Freddy's nginx will reverse proxy Sullivan services over Tailscale." >> $GITHUB_STEP_SUMMARY

    # ==========================================================================
    # SSL CERTIFICATE MANAGEMENT
    # ==========================================================================

    # ==========================================================================
    # SSL CERTIFICATE GENERATION
    # ==========================================================================
    ssl-generate:
        name: üîê Generate/Renew SSL Certificates
        runs-on: ubuntu-latest
        timeout-minutes: 15
        needs: [dns-update]
        if: |
            github.event_name == 'schedule' ||
            github.event_name == 'workflow_dispatch' ||
            github.event_name == 'push' ||
            needs.dns-update.outputs.dns-updated == 'true' ||
            inputs.force_ssl_regen == true

        outputs:
            cert-ready: ${{ steps.certbot.outputs.cert-ready }}
            cert-type: ${{ steps.certbot.outputs.cert-type }}

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üîå Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  target-ssh-port: ${{ secrets.SSH_PORT || '22' }}

            - name: üîå Verify Tailscale connection
              run: |
                  echo "üîå Testing Tailscale connection before SSL operations..."

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  # Test connection
                  if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ~/.ssh/id_rsa \
                    -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} \
                    'echo "Connection successful"'; then
                    echo "‚úÖ Tailscale connection working"
                  else
                    echo "‚ùå Failed to connect via Tailscale"
                    echo "Check that:"
                    echo "  - Tailscale is running on Freddy"
                    echo "  - SSH_KEY secret is correct"
                    echo "  - FREDDY_TAILSCALE_IP is correct"
                    rm -f ~/.ssh/id_rsa
                    exit 1
                  fi

                  # Cleanup SSH key
                  rm -f ~/.ssh/id_rsa
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: üßπ Clean corrupted SSL certificates
              if: inputs.force_ssl_regen == true
              run: |
                  echo "üßπ Forcing comprehensive SSL certificate cleanup..."
                  echo "This will remove ALL existing certificates and volumes"

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} << 'ENDSSH'

                  set -e
                  echo "================================================"
                  echo "  SSL CERTIFICATE CLEANUP"
                  echo "================================================"

                  # Stop all services to release volume locks
                  echo "‚Üí Stopping all services..."
                  cd ~/freddy 2>/dev/null || true
                  ./run.sh stop 2>/dev/null || docker compose down 2>/dev/null || true

                  # Stop and remove nginx specifically
                  echo "‚Üí Removing nginx container..."
                  docker stop nginx 2>/dev/null || true
                  docker rm -f nginx 2>/dev/null || true

                  # Remove ssl-certs Docker volume
                  echo "‚Üí Removing ssl-certs Docker volume..."
                  docker volume rm ssl-certs 2>/dev/null || true
                  docker volume rm freddy_ssl-certs 2>/dev/null || true

                  # Clean host certificate directories
                  echo "‚Üí Cleaning host certificate directories..."
                  sudo rm -rf /opt/ssl/7gram.xyz 2>/dev/null || true
                  sudo rm -rf /etc/letsencrypt 2>/dev/null || true
                  sudo rm -rf /opt/letsencrypt 2>/dev/null || true

                  # Clean project certificate directories
                  echo "‚Üí Cleaning project certificate directories..."
                  rm -rf ~/freddy/ssl/ 2>/dev/null || true
                  rm -rf ~/freddy/certs/ 2>/dev/null || true
                  rm -rf ~/freddy/nginx/ssl/ 2>/dev/null || true
                  rm -rf ~/freddy/nginx/certs/ 2>/dev/null || true

                  # Remove dangling volumes
                  echo "‚Üí Pruning dangling volumes..."
                  docker volume prune -f 2>/dev/null || true

                  # Remove any stopped containers
                  echo "‚Üí Pruning stopped containers..."
                  docker container prune -f 2>/dev/null || true

                  echo ""
                  echo "‚úÖ Complete cleanup finished"
                  echo "   Ready for fresh SSL certificate generation"
                  echo "================================================"
                  ENDSSH

                  # Cleanup SSH key
                  rm -f ~/.ssh/id_rsa
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: üîç Verify clean slate before certificate generation
              run: |
                  echo "üîç Verifying system is clean before SSL generation..."

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} << 'ENDSSH'

                  echo "Checking for lingering SSL artifacts..."

                  # Check for ssl-certs volume
                  if docker volume inspect ssl-certs >/dev/null 2>&1; then
                    echo "‚ö†Ô∏è WARNING: ssl-certs volume still exists!"
                    docker volume rm ssl-certs || true
                  else
                    echo "‚úì ssl-certs volume is clean"
                  fi

                  # Check for nginx container
                  if docker ps -a --filter "name=nginx" --format '{{.Names}}' | grep -q "nginx"; then
                    echo "‚ö†Ô∏è WARNING: nginx container still exists!"
                    docker rm -f nginx || true
                  else
                    echo "‚úì nginx container is clean"
                  fi

                  # Check host certificate directories
                  if [ -d "/opt/ssl/7gram.xyz" ] || [ -d "/etc/letsencrypt" ]; then
                    echo "‚ö†Ô∏è WARNING: Host certificate directories exist, cleaning..."
                    sudo rm -rf /opt/ssl/7gram.xyz /etc/letsencrypt 2>/dev/null || true
                  else
                    echo "‚úì Host directories are clean"
                  fi

                  echo ""
                  echo "‚úÖ Clean slate verified - ready for certificate generation"
                  ENDSSH

                  # Cleanup SSH key
                  rm -f ~/.ssh/id_rsa
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: üîê Generate SSL Certificates (Let's Encrypt + Cloudflare DNS)
              id: certbot
              uses: nuniesmith/actions/.github/actions/ssl-certbot-cloudflare@main
              with:
                  domain: ${{ env.DOMAIN }}
                  additional-domains: "*.7gram.xyz,nc.7gram.xyz,photo.7gram.xyz,home.7gram.xyz,audiobook.7gram.xyz,sullivan.7gram.xyz,*.sullivan.7gram.xyz"
                  cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  email: ${{ secrets.SSL_EMAIL }}
                  propagation-seconds: 60
                  staging: false
                  fallback-to-self-signed: true
                  deploy-to-server: true
                  ssh-host: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  ssh-port: ${{ secrets.SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.SSH_KEY }}
                  docker-volume-name: ssl-certs
                  docker-username: ${{ secrets.DOCKER_USERNAME }}
                  docker-token: ${{ secrets.DOCKER_TOKEN }}

            - name: üìã SSL Summary
              run: |
                  echo "## üîê SSL Certificates" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
                  echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
                  echo "| Domain | \`${{ env.DOMAIN }}\` |" >> $GITHUB_STEP_SUMMARY
                  echo "| Status | ${{ steps.certbot.outputs.cert-ready == 'true' && '‚úÖ Ready' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
                  echo "| Type | \`${{ steps.certbot.outputs.cert-type }}\` |" >> $GITHUB_STEP_SUMMARY
                  echo "| Expires | ${{ steps.certbot.outputs.expiry-date }} |" >> $GITHUB_STEP_SUMMARY

            - name: ‚úÖ Post-generation certificate verification
              if: steps.certbot.outputs.cert-ready == 'true'
              run: |
                  echo "‚úÖ Verifying generated certificates are valid and properly deployed..."

                  # Setup SSH key
                  mkdir -p ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT || '22' }} \
                    ${{ secrets.SSH_USER || 'actions' }}@${{ secrets.FREDDY_TAILSCALE_IP }} << 'ENDSSH'

                  echo "================================================"
                  echo "  POST-GENERATION CERTIFICATE VERIFICATION"
                  echo "================================================"

                  # Check if ssl-certs volume exists
                  if ! docker volume inspect ssl-certs >/dev/null 2>&1; then
                    echo "‚ùå ERROR: ssl-certs volume not found!"
                    exit 1
                  fi
                  echo "‚úì ssl-certs volume exists"

                  # Check certificate files exist in volume
                  CERT_EXISTS=$(docker run --rm -v ssl-certs:/certs:ro busybox:latest test -f /certs/live/7gram.xyz/fullchain.pem && echo "yes" || echo "no")
                  KEY_EXISTS=$(docker run --rm -v ssl-certs:/certs:ro busybox:latest test -f /certs/live/7gram.xyz/privkey.pem && echo "yes" || echo "no")

                  if [ "$CERT_EXISTS" != "yes" ] || [ "$KEY_EXISTS" != "yes" ]; then
                    echo "‚ùå ERROR: Certificate files not found in volume!"
                    exit 1
                  fi
                  echo "‚úì Certificate files exist in volume"

                  # List certificate files
                  echo ""
                  echo "Certificate files:"
                  docker run --rm -v ssl-certs:/certs:ro busybox:latest ls -lah /certs/live/7gram.xyz/

                  # Verify certificate and private key match
                  echo ""
                  echo "Verifying certificate/key pair match..."
                  CERT_MOD=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -noout -modulus -in /certs/live/7gram.xyz/fullchain.pem | openssl md5 2>/dev/null)
                  KEY_MOD=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl rsa -noout -modulus -in /certs/live/7gram.xyz/privkey.pem | openssl md5 2>/dev/null)

                  echo "Certificate modulus: $CERT_MOD"
                  echo "Private key modulus: $KEY_MOD"

                  if [ "$CERT_MOD" = "$KEY_MOD" ] && [ -n "$CERT_MOD" ]; then
                    echo "‚úÖ Certificate and private key MATCH!"
                  else
                    echo "‚ùå ERROR: Certificate and private key DO NOT MATCH!"
                    echo "   This indicates the certificate generation failed!"
                    exit 1
                  fi

                  # Check certificate validity
                  echo ""
                  echo "Checking certificate validity..."
                  docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -in /certs/live/7gram.xyz/fullchain.pem -noout -dates
                  docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -in /certs/live/7gram.xyz/fullchain.pem -noout -issuer

                  echo ""
                  echo "‚úÖ All certificate verification checks PASSED!"
                  echo "   Certificates are valid and ready for deployment"
                  echo "================================================"
                  ENDSSH

                  # Cleanup SSH key
                  rm -f ~/.ssh/id_rsa
              env:
                  SSH_KEY: ${{ secrets.SSH_KEY }}

            - name: ‚ùå Fail workflow if SSL generation failed
              if: steps.certbot.outputs.cert-ready != 'true'
              run: |
                  echo "‚ùå SSL certificate generation FAILED!"
                  echo "Cannot proceed with deployment without valid SSL certificates."
                  echo "Check the certbot step logs for details."
                  exit 1

    # ==========================================================================
    # DEPLOYMENT
    # ==========================================================================
    deploy:
        name: üöÄ Deploy to Freddy
        runs-on: ubuntu-latest
        timeout-minutes: 15
        needs: [dns-update, ssl-generate]
        if: |
            always() &&
            needs.ssl-generate.result == 'success' &&
            (needs.dns-update.result == 'success' || needs.dns-update.result == 'skipped') &&
            (
                github.event_name == 'push' ||
                (github.event_name == 'workflow_dispatch' && !inputs.skip_deploy)
            )

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            # ======================================================================
            # TAILSCALE CONNECTION
            # ======================================================================
            - name: üîå Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  target-ssh-port: ${{ secrets.SSH_PORT || '22' }}

            # ======================================================================
            # DEPLOY VIA SSH
            # ======================================================================
            - name: üöÄ Deploy via SSH
              id: deploy
              if: steps.tailscale.outputs.connected == 'true'
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  port: ${{ secrets.SSH_PORT || '22' }}
                  username: ${{ secrets.SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.SSH_KEY }}
                  project-path: ${{ env.PROJECT_PATH }}
                  git-pull: false
                  git-branch: ${{ github.ref_name }}
                  docker-pull: false
                  docker-prune: false
                  pre-deploy-command: |
                      echo "üè† Deploying to Freddy server..."

                      # Create project directory if it doesn't exist
                      echo "üìÅ Ensuring project directory exists..."
                      mkdir -p ${{ env.PROJECT_PATH }}

                      # Stop existing services to release file locks
                      echo "üõë Stopping existing services..."
                      if [ -d "${{ env.PROJECT_PATH }}" ]; then
                        cd ${{ env.PROJECT_PATH }}
                        ./run.sh stop 2>/dev/null || docker compose down 2>/dev/null || true
                        cd ~
                      fi

                      # ============================================================
                      # COMPREHENSIVE SSL CERTIFICATE CLEANUP
                      # ============================================================
                      echo ""
                      echo "üßπ Cleaning up old/corrupted SSL certificates..."

                      # Stop and remove nginx container specifically
                      echo "  ‚Üí Stopping nginx container..."
                      docker stop nginx 2>/dev/null || true
                      docker rm -f nginx 2>/dev/null || true

                      # Remove ssl-certs Docker volume (forces fresh cert generation)
                      echo "  ‚Üí Removing ssl-certs Docker volume..."
                      docker volume rm ssl-certs 2>/dev/null || true

                      # Clean any host-mounted certificate directories
                      echo "  ‚Üí Cleaning host certificate directories..."
                      sudo rm -rf ${{ env.SSL_CERT_PATH }} 2>/dev/null || true
                      sudo rm -rf /etc/letsencrypt 2>/dev/null || true
                      sudo rm -rf /opt/letsencrypt 2>/dev/null || true

                      # Clean project-level cert directories
                      if [ -d "${{ env.PROJECT_PATH }}" ]; then
                        cd ${{ env.PROJECT_PATH }}
                        rm -rf ssl/ certs/ certificates/ .ssl/ 2>/dev/null || true
                        rm -rf nginx/ssl/ nginx/certs/ 2>/dev/null || true
                      fi

                      # Remove any dangling certificate-related volumes
                      echo "  ‚Üí Removing dangling volumes..."
                      docker volume prune -f 2>/dev/null || true

                      echo "‚úÖ SSL cleanup complete - ready for fresh certificates"
                      echo ""
                      # ============================================================

                      # Handle git repository setup
                      cd ${{ env.PROJECT_PATH }}

                      if [ -d .git ] && git status >/dev/null 2>&1; then
                        echo "üì• Updating existing repository..."
                        git fetch origin
                        git checkout ${{ github.ref_name }}
                        git pull origin ${{ github.ref_name }} || {
                          echo "‚ö†Ô∏è Git pull failed, doing hard reset..."
                          git reset --hard origin/${{ github.ref_name }}
                        }
                      else
                        echo "üì• Cloning repository (first deployment)..."
                        cd ~
                        rm -rf ${{ env.PROJECT_PATH }}
                        git clone https://github.com/${{ github.repository }}.git ${{ env.PROJECT_PATH }}
                        cd ${{ env.PROJECT_PATH }}
                        git checkout ${{ github.ref_name }}
                      fi

                      # Ensure run.sh is executable
                      chmod +x ./run.sh 2>/dev/null || true

                      # Verify SSL certificates are ready from ssl-generate job
                      echo "üîç Checking for fresh SSL certificates..."
                      CERT_EXISTS=$(docker run --rm -v ssl-certs:/certs:ro busybox:latest test -f /certs/live/${{ env.DOMAIN }}/fullchain.pem && echo "yes" || echo "no")

                      if [ "$CERT_EXISTS" = "yes" ]; then
                        echo "‚úÖ Fresh SSL certificates found in Docker volume"
                        docker run --rm -v ssl-certs:/certs:ro busybox:latest ls -lah /certs/live/${{ env.DOMAIN }}/

                        # Verify certificate and key match
                        echo "üîê Verifying certificate/key pair..."
                        CERT_MOD=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl x509 -noout -modulus -in /certs/live/${{ env.DOMAIN }}/fullchain.pem | openssl md5 2>/dev/null || echo "cert-error")
                        KEY_MOD=$(docker run --rm -v ssl-certs:/certs:ro alpine/openssl rsa -noout -modulus -in /certs/live/${{ env.DOMAIN }}/privkey.pem | openssl md5 2>/dev/null || echo "key-error")

                        if [ "$CERT_MOD" = "$KEY_MOD" ] && [ "$CERT_MOD" != "cert-error" ]; then
                          echo "‚úÖ Certificate and private key match!"
                        else
                          echo "‚ùå ERROR: Certificate and key DO NOT match!"
                          echo "   This should not happen after cleanup and regeneration"
                          exit 1
                        fi
                      else
                        echo "‚ö†Ô∏è SSL certificates not found in Docker volume"
                        echo "   They should have been generated in the ssl-generate job"
                        echo "   Deployment will continue but nginx may fail to start"
                      fi

                      # Load environment variables
                      if [ -f .env ]; then
                        set -a && source .env && set +a
                        echo "‚úì Environment loaded"
                      fi

                  deploy-command: |
                      cd ${{ env.PROJECT_PATH }}

                      # Deploy using run.sh
                      if [ -x "./run.sh" ]; then
                        echo "üê≥ Stopping existing services..."
                        ./run.sh stop 2>/dev/null || true
                        echo "üê≥ Starting services in production mode..."
                        ./run.sh prod start
                      else
                        echo "‚ö†Ô∏è run.sh not found, using docker compose directly"
                        docker compose pull --ignore-pull-failures
                        docker compose up -d --remove-orphans
                      fi

                  post-deploy-command: |
                      cd ${{ env.PROJECT_PATH }}

                      echo ""
                      echo "üìä Service Status:"
                      docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || docker ps --format "table {{.Names}}\t{{.Status}}"

                      echo ""
                      echo "‚úÖ Deployment complete!"

            # ======================================================================
            # HEALTH CHECKS
            # ======================================================================
            - name: üè• Run Health Checks
              id: health-checks
              if: always() && steps.deploy.outcome == 'success'
              uses: nuniesmith/actions/.github/actions/health-check@main
              with:
                  containers: nginx,photoprism,nextcloud,homeassistant,audiobookshelf
                  ssh-host: ${{ secrets.FREDDY_TAILSCALE_IP }}
                  ssh-port: ${{ secrets.SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.SSH_KEY }}
                  initial-delay: 30
                  retry-count: 3
                  retry-delay: 10
                  fail-on-unhealthy: false

            # ======================================================================
            # DISCORD NOTIFICATION (Optional)
            # ======================================================================
            - name: üì£ Notify deployment
              if: always()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "üè† Freddy Deployment"
                  description: "Personal services server deployment"
                  status: ${{ steps.deploy.outcome == 'success' && 'success' || 'failure' }}
                  include-repo-info: true
                  fields: |
                      [
                        {"name": "Server", "value": "Freddy", "inline": true},
                        {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true},
                        {"name": "Health", "value": "${{ steps.health-checks.outputs.healthy == 'true' && '‚úÖ Healthy' || '‚ö†Ô∏è Check Required' }}", "inline": true}
                      ]

    # ==========================================================================
    # PIPELINE SUMMARY
    # ==========================================================================
    summary:
        name: üìä Summary
        runs-on: ubuntu-latest
        timeout-minutes: 10
        needs: [dns-update, ssl-generate, deploy]
        if: always()

        steps:
            - name: üìä Generate summary
              run: |
                  echo "## üè† Freddy Deployment Summary" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
                  echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

                  # DNS Update status
                  if [ "${{ needs.dns-update.result }}" = "success" ]; then
                    echo "| üåê DNS Update | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY
                  elif [ "${{ needs.dns-update.result }}" = "skipped" ]; then
                    echo "| üåê DNS Update | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "| üåê DNS Update | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
                  fi

                  # SSL Certificates status
                  if [ "${{ needs.ssl-generate.result }}" = "success" ]; then
                    echo "| üîê SSL Certs | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY
                  elif [ "${{ needs.ssl-generate.result }}" = "skipped" ]; then
                    echo "| üîê SSL Certs | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "| üîê SSL Certs | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
                  fi

                  # Deploy status
                  if [ "${{ needs.deploy.result }}" = "success" ]; then
                    echo "| üöÄ Deploy | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY
                  elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
                    echo "| üöÄ Deploy | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "| üöÄ Deploy | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
                  fi

                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "### üìã Details" >> $GITHUB_STEP_SUMMARY
                  echo "- **Server:** Freddy (Personal Services)" >> $GITHUB_STEP_SUMMARY
                  echo "- **Domain:** ${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
                  echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
                  echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
                  echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "### üîß Architecture" >> $GITHUB_STEP_SUMMARY
                  echo "- All DNS records point to Freddy's Tailscale IP" >> $GITHUB_STEP_SUMMARY
                  echo "- Freddy's nginx reverse proxies Sullivan services over Tailscale" >> $GITHUB_STEP_SUMMARY
                  echo "- SSL certificates cover both Freddy and Sullivan subdomains" >> $GITHUB_STEP_SUMMARY

            - name: ‚ùå Fail on deployment error
              if: needs.deploy.result == 'failure'
              run: |
                  echo "::error::Deployment failed"
                  exit 1
